// DO NOT EDIT: generated by github.com/tim-online/go-afas-profit-rest/generate

package afas

import (
	"encoding/json"

	"github.com/aodin/date"
	"github.com/cockroachdb/apd"
	"github.com/cydev/zero"
)

// FiEntryPar
type FiEntryPar struct {
	Boekjaar                       int         `json:"Year"`           // Boekjaar
	Periode                        int         `json:"Peri"`           // Periode
	NummerAdministratie            int         `json:"UnId,omitempty"` // Nummer administratie
	Dagboek                        string      `json:"JoCo"`           // Dagboek
	MaakVerbijzonderingscode       bool        `json:"AdDc,omitempty"` // Maak verbijzonderingscode
	MaakVerbijzonderingstoewijzing bool        `json:"AdDa,omitempty"` // Maak verbijzonderingstoewijzing
	TypeBoeking                    int         `json:"PrTp,omitempty"` // Type boeking
	AutonummeringFactuur           bool        `json:"AuNu,omitempty"` // Autonummering factuur
	FiEntries                      []FiEntries `json:"FiEntries"`      // FiEntries

}

func (f FiEntryPar) MarshalJSON() ([]byte, error) {
	// If struct is empty: do nothing
	if zero.IsZero(f) {
		return []byte("null"), nil
	}

	type alias FiEntryPar

	// type to json
	b, err := json.Marshal(alias(f))
	if err != nil {
		return b, err
	}

	// json to map with preservation of json struct tags
	m := map[string]interface{}{}
	json.Unmarshal(b, &m)

	jsonFields := f.JSONFields()
	fields := map[string]interface{}{}
	jsonObjects := f.JSONObjects()
	objects := map[string]interface{}{}
	for k, v := range m {
		for _, f := range jsonFields {
			if k == f {
				// value is a field
				fields[k] = v
			}
		}

		for _, f := range jsonObjects {
			if k == f {
				// skip empty objects
				// @TODO: move this logic to an Objects struct aliasing
				// map[string]interface{}
				if v == nil || zero.IsZero(v) {
					continue
				}

				// value is an object and not zero
				objects[k] = v
			}
		}
	}

	type Element struct {
		DBID    string                 `json:"@DbId,omitempty"`
		Fields  map[string]interface{} `json:"Fields,omitempty"`
		Objects map[string]interface{} `json:"Objects,omitempty"`
	}

	type Elements struct {
		Element []Element `json:"Element"`
	}

	structure := Elements{
		[]Element{
			Element{
				Fields:  fields,
				Objects: objects,
			},
		},
	}

	return json.Marshal(structure)
}

func (k FiEntryPar) JSONFields() []string {
	return []string{
		"Year",
		"Peri",
		"UnId",
		"JoCo",
		"AdDc",
		"AdDa",
		"PrTp",
		"AuNu",
		"",
	}
}

func (k FiEntryPar) JSONObjects() []string {
	return []string{
		"FiEntries",
	}
}

// FiEntries
type FiEntries struct {
	NummerJournaalpost         int          `json:"EnNo,omitempty"`                              // Nummer journaalpost
	KenmerkRekening            string       `json:"VaAs"`                                        // Kenmerk rekening
	Rekeningnummer             string       `json:"AcNr"`                                        // Rekeningnummer
	DatumBoeking               date.Date    `json:"EnDa"`                                        // Datum boeking
	Boekstukdatum              date.Date    `json:"BpDa"`                                        // Boekstukdatum
	Boekstuknummer             string       `json:"BpNr,omitempty"`                              // Boekstuknummer
	Factuurnummer              string       `json:"InId,omitempty"`                              // Factuurnummer
	OmschrijvingBoeking        string       `json:"Ds,omitempty"`                                // Omschrijving boeking
	BedragDebet                *apd.Decimal `json:"AmDe,omitempty"`                              // Bedrag debet
	BedragCredit               *apd.Decimal `json:"AmCr,omitempty"`                              // Bedrag credit
	BtwCode                    string       `json:"VaId,omitempty"`                              // Btw-code
	Valuta                     string       `json:"CuId,omitempty"`                              // Valuta
	Koers                      *apd.Decimal `json:"Rate,omitempty"`                              // Koers
	ValutabedragDebet          *apd.Decimal `json:"AmDc,omitempty"`                              // Valutabedrag debet
	ValutabedragCredit         *apd.Decimal `json:"AmCc,omitempty"`                              // Valutabedrag credit
	Vervaldatum                *date.Date   `json:"DaEx,omitempty"`                              // Vervaldatum
	Betalingskenmerk           string       `json:"PaId,omitempty"`                              // Betalingskenmerk
	Beoordelaar                string       `json:"Judg,omitempty"`                              // Beoordelaar
	BlokkerenVoorBetaling      bool         `json:"BlPa,omitempty"`                              // Blokkeren voor betaling
	BedragGRekening            *apd.Decimal `json:"AmGa,omitempty"`                              // Bedrag G-rekening
	NummerReservering          int          `json:"RsNo,omitempty"`                              // Nummer reservering
	NummerVerplichting         int          `json:"CmNo,omitempty"`                              // Nummer verplichting
	AutomatischBetalenincasso  bool         `json:"AuPa,omitempty"`                              // Automatisch betalen/incasso
	Terugbetalen               bool         `json:"PaBa,omitempty"`                              // Terugbetalen
	Campagne                   int          `json:"CaId,omitempty"`                              // Campagne
	Verkoopordernummer         string       `json:"OrNu,omitempty"`                              // Verkoopordernummer
	Afletterreferentie         string       `json:"Mref,omitempty"`                              // Afletterreferentie
	Project                    string       `json:"PrId,omitempty"`                              // Project
	AfwijkendeBetaalrekeningnr string       `json:"BankAccount,omitempty"`                       // Afwijkende betaalrekeningnr.
	AfwijkendeBetaalrekening   int          `json:"IdBa,omitempty"`                              // Afwijkende betaalrekening
	AfwijkendKenmerkMachtiging string       `json:"DdId,omitempty"`                              // Afwijkend kenmerk machtiging
	DagenKredietbeperking      int          `json:"DaCl,omitempty"`                              // Dagen kredietbeperking
	BetalingskortingInclBtw    bool         `json:"VaPa,omitempty"`                              // Betalingskorting incl. btw
	DagenBetalingskorting      int          `json:"DaDp,omitempty"`                              // Dagen betalingskorting
	Betalingskorting           *apd.Decimal `json:"AmDp,omitempty"`                              // Betalingskorting
	BetalingskortingInValuta   *apd.Decimal `json:"AcPa,omitempty"`                              // Betalingskorting in valuta
	FinoFixtype                string       `json:"UF4EB2F8D4E77CFB7A33049AFC5CFD82B,omitempty"` // FinoFixtype
	FinoFixcddb                string       `json:"U2A488F35402584E02864E6817AAAB1F8,omitempty"` // FinoFixcddb
	FinoFixintern              string       `json:"U8B1C568C48D3241095F8A1879EF2A370,omitempty"` // FinoFixintern
	FinoFixjour                string       `json:"UA4AB1DAC43F80AC0D0321F917D117AD0,omitempty"` // FinoFixjour
	FinoFixgrootrek            string       `json:"U75DDCA1B478DFE57904568BE42A4A6D4,omitempty"` // FinoFixgrootrek
	FinoFixexternfac           string       `json:"U280C5DFA4717A8925BAF5E8B42234960,omitempty"` // FinoFixexternfac
	FinoFixserienr             string       `json:"UEFB570A246814E489B9DDB8E6EFCE4BC,omitempty"` // FinoFixserienr
	FiDimEntries               FiDimEntries `json:"FiDimEntries"`                                // FiDimEntries
	FiPrjEntries               FiPrjEntries `json:"FiPrjEntries"`                                // FiPrjEntries

}

func (f FiEntries) MarshalJSON() ([]byte, error) {
	// If struct is empty: do nothing
	if zero.IsZero(f) {
		return []byte("null"), nil
	}

	type alias FiEntries

	// type to json
	b, err := json.Marshal(alias(f))
	if err != nil {
		return b, err
	}

	// json to map with preservation of json struct tags
	m := map[string]interface{}{}
	json.Unmarshal(b, &m)

	jsonFields := f.JSONFields()
	fields := map[string]interface{}{}
	jsonObjects := f.JSONObjects()
	objects := map[string]interface{}{}
	for k, v := range m {
		for _, f := range jsonFields {
			if k == f {
				// value is a field
				fields[k] = v
			}
		}

		for _, f := range jsonObjects {
			if k == f {
				// skip empty objects
				// @TODO: move this logic to an Objects struct aliasing
				// map[string]interface{}
				if v == nil || zero.IsZero(v) {
					continue
				}

				// value is an object and not zero
				objects[k] = v
			}
		}
	}

	type Element struct {
		DBID    string                 `json:"@DbId,omitempty"`
		Fields  map[string]interface{} `json:"Fields,omitempty"`
		Objects map[string]interface{} `json:"Objects,omitempty"`
	}

	type Elements struct {
		Element []Element `json:"Element"`
	}

	structure := Elements{
		[]Element{
			Element{
				Fields:  fields,
				Objects: objects,
			},
		},
	}

	return json.Marshal(structure)
}

func (k FiEntries) JSONFields() []string {
	return []string{
		"EnNo",
		"VaAs",
		"AcNr",
		"EnDa",
		"BpDa",
		"BpNr",
		"InId",
		"Ds",
		"AmDe",
		"AmCr",
		"VaId",
		"CuId",
		"Rate",
		"AmDc",
		"AmCc",
		"DaEx",
		"PaId",
		"Judg",
		"BlPa",
		"AmGa",
		"RsNo",
		"CmNo",
		"AuPa",
		"PaBa",
		"CaId",
		"OrNu",
		"Mref",
		"PrId",
		"BankAccount",
		"IdBa",
		"DdId",
		"DaCl",
		"VaPa",
		"DaDp",
		"AmDp",
		"AcPa",
		"UF4EB2F8D4E77CFB7A33049AFC5CFD82B",
		"U2A488F35402584E02864E6817AAAB1F8",
		"U8B1C568C48D3241095F8A1879EF2A370",
		"UA4AB1DAC43F80AC0D0321F917D117AD0",
		"U75DDCA1B478DFE57904568BE42A4A6D4",
		"U280C5DFA4717A8925BAF5E8B42234960",
		"UEFB570A246814E489B9DDB8E6EFCE4BC",
		"",
		"",
	}
}

func (k FiEntries) JSONObjects() []string {
	return []string{
		"FiDimEntries",
		"FiPrjEntries",
	}
}

// FiDimEntries
type FiDimEntries struct {
	CodeVerbijzonderingsas1 string       `json:"DiC1,omitempty"` // Code verbijzonderingsas 1
	CodeVerbijzonderingsas2 string       `json:"DiC2,omitempty"` // Code verbijzonderingsas 2
	CodeVerbijzonderingsas3 string       `json:"DiC3,omitempty"` // Code verbijzonderingsas 3
	CodeVerbijzonderingsas4 string       `json:"DiC4,omitempty"` // Code verbijzonderingsas 4
	CodeVerbijzonderingsas5 string       `json:"DiC5,omitempty"` // Code verbijzonderingsas 5
	BedragDebet             *apd.Decimal `json:"AmDe,omitempty"` // Bedrag debet
	BedragCredit            *apd.Decimal `json:"AmCr,omitempty"` // Bedrag credit
	Valuta                  string       `json:"CuId,omitempty"` // Valuta
	ValutabedragDebet       *apd.Decimal `json:"AmDc,omitempty"` // Valutabedrag debet
	ValutabedragCredit      *apd.Decimal `json:"AmCc,omitempty"` // Valutabedrag credit
	Aantal                  *apd.Decimal `json:"Quan,omitempty"` // Aantal

}

func (f FiDimEntries) MarshalJSON() ([]byte, error) {
	// If struct is empty: do nothing
	if zero.IsZero(f) {
		return []byte("null"), nil
	}

	type alias FiDimEntries

	// type to json
	b, err := json.Marshal(alias(f))
	if err != nil {
		return b, err
	}

	// json to map with preservation of json struct tags
	m := map[string]interface{}{}
	json.Unmarshal(b, &m)

	jsonFields := f.JSONFields()
	fields := map[string]interface{}{}
	jsonObjects := f.JSONObjects()
	objects := map[string]interface{}{}
	for k, v := range m {
		for _, f := range jsonFields {
			if k == f {
				// value is a field
				fields[k] = v
			}
		}

		for _, f := range jsonObjects {
			if k == f {
				// skip empty objects
				// @TODO: move this logic to an Objects struct aliasing
				// map[string]interface{}
				if v == nil || zero.IsZero(v) {
					continue
				}

				// value is an object and not zero
				objects[k] = v
			}
		}
	}

	type Element struct {
		DBID    string                 `json:"@DbId,omitempty"`
		Fields  map[string]interface{} `json:"Fields,omitempty"`
		Objects map[string]interface{} `json:"Objects,omitempty"`
	}

	type Elements struct {
		Element []Element `json:"Element"`
	}

	structure := Elements{
		[]Element{
			Element{
				Fields:  fields,
				Objects: objects,
			},
		},
	}

	return json.Marshal(structure)
}

func (k FiDimEntries) JSONFields() []string {
	return []string{
		"DiC1",
		"DiC2",
		"DiC3",
		"DiC4",
		"DiC5",
		"AmDe",
		"AmCr",
		"CuId",
		"AmDc",
		"AmCc",
		"Quan",
	}
}

func (k FiDimEntries) JSONObjects() []string {
	return []string{}
}

// FiPrjEntries
type FiPrjEntries struct {
	Project                       string       `json:"PrId"`           // Project
	Projectfase                   string       `json:"PrSt,omitempty"` // Projectfase
	TypeItem                      string       `json:"VaIt,omitempty"` // Type item
	Itemcode                      string       `json:"ItCd"`           // Itemcode
	Omschrijving                  string       `json:"Ds,omitempty"`   // Omschrijving
	Kostprijs                     *apd.Decimal `json:"AmCo"`           // Kostprijs
	Doorbelasten                  bool         `json:"Ch,omitempty"`   // Doorbelasten
	BedragDoorbelastenBasisvaluta *apd.Decimal `json:"AmSe,omitempty"` // Bedrag doorbelasten basisvaluta
	BedragDoorbelasten            *apd.Decimal `json:"AmFc,omitempty"` // Bedrag doorbelasten
	Valuta                        string       `json:"CuId,omitempty"` // Valuta
	Valutakoers                   *apd.Decimal `json:"Rate"`           // Valutakoers
	RapporterendeEenheid          int          `json:"Di01,omitempty"` // Rapporterende eenheid
	Kostenplaats                  int          `json:"Di02,omitempty"` // Kostenplaats
	Kostendrager                  int          `json:"Di03,omitempty"` // Kostendrager
	Overig                        int          `json:"Di04,omitempty"` // Overig
	ProjectFinancieel             int          `json:"Di05,omitempty"` // Project Financieel
	Aantal                        *apd.Decimal `json:"Qu,omitempty"`   // Aantal
	Overhead                      *apd.Decimal `json:"OvPc,omitempty"` // Overhead (%)
	Bewakingscode                 string       `json:"MoId,omitempty"` // Bewakingscode
	TypeProjectkosten             string       `json:"CoTy,omitempty"` // Type projectkosten

}

func (f FiPrjEntries) MarshalJSON() ([]byte, error) {
	// If struct is empty: do nothing
	if zero.IsZero(f) {
		return []byte("null"), nil
	}

	type alias FiPrjEntries

	// type to json
	b, err := json.Marshal(alias(f))
	if err != nil {
		return b, err
	}

	// json to map with preservation of json struct tags
	m := map[string]interface{}{}
	json.Unmarshal(b, &m)

	jsonFields := f.JSONFields()
	fields := map[string]interface{}{}
	jsonObjects := f.JSONObjects()
	objects := map[string]interface{}{}
	for k, v := range m {
		for _, f := range jsonFields {
			if k == f {
				// value is a field
				fields[k] = v
			}
		}

		for _, f := range jsonObjects {
			if k == f {
				// skip empty objects
				// @TODO: move this logic to an Objects struct aliasing
				// map[string]interface{}
				if v == nil || zero.IsZero(v) {
					continue
				}

				// value is an object and not zero
				objects[k] = v
			}
		}
	}

	type Element struct {
		DBID    string                 `json:"@DbId,omitempty"`
		Fields  map[string]interface{} `json:"Fields,omitempty"`
		Objects map[string]interface{} `json:"Objects,omitempty"`
	}

	type Elements struct {
		Element []Element `json:"Element"`
	}

	structure := Elements{
		[]Element{
			Element{
				Fields:  fields,
				Objects: objects,
			},
		},
	}

	return json.Marshal(structure)
}

func (k FiPrjEntries) JSONFields() []string {
	return []string{
		"PrId",
		"PrSt",
		"VaIt",
		"ItCd",
		"Ds",
		"AmCo",
		"Ch",
		"AmSe",
		"AmFc",
		"CuId",
		"Rate",
		"Di01",
		"Di02",
		"Di03",
		"Di04",
		"Di05",
		"Qu",
		"OvPc",
		"MoId",
		"CoTy",
	}
}

func (k FiPrjEntries) JSONObjects() []string {
	return []string{}
}
