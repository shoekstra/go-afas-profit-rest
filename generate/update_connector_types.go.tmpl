// DO NOT EDIT: generated by github.com/tim-online/go-afas-profit-rest/generate

package afas

import (
	"encoding/json"
	"errors"
	"time"
	"unicode/utf8"

	// "github.com/cockroachdb/apd"
	"github.com/cydev/zero"
)

{{range .Objects}}

{{if .Plural}}
// {{.Plural}}
type {{.Plural}} []{{.Name}}

func ({{.Variable}} {{.Plural}}) MarshalJSON() ([]byte, error) {
	// If struct is empty: do nothing
	if zero.IsZero({{.Variable}}) {
		return []byte("null"), nil
	}

	structure := Elements{}
	for _, f := range {{.Variable}} {
		el, err := f.ToElement()
		if err != nil {
			return []byte{}, err
		}

		if zero.IsZero(el) {
			continue
		}

		structure = append(structure, el)
	}

	if len(structure) == 0 {
		return []byte("null"), nil
	}

	return json.Marshal(structure)
}
{{end}}

// {{.Comment}}
type {{.Name}} struct {
	{{range .Fields}} {{.Name}} {{.Type}} `json:"{{.JSONName}}{{.Tags}}"` // {{.Comment}}
	{{end}}
}

func ({{.Variable}} {{.Name}}) MarshalJSON() ([]byte, error) {
	el, err := {{.Variable}}.ToElement()
	if err != nil {
		return []byte{}, err
	}

	return json.Marshal(el)
}

func ({{.Variable}} {{.Name}}) ToElement() (Element, error) {
	// If struct is empty: do nothing
	if zero.IsZero({{.Variable}}) {
		return Element{}, nil
	}

	type alias {{.Name}}

	// type to json
	b, err := json.Marshal(alias({{.Variable}}))
	if err != nil {
		return Element{}, err
	}

	// json to map with preservation of json struct tags
	m := map[string]interface{}{}
	json.Unmarshal(b, &m)

	jsonFields := {{.Variable}}.JSONFields()
	fields := map[string]interface{}{}
	jsonObjects := {{.Variable}}.JSONObjects()
	objects := map[string]interface{}{}
	for k, v := range m {
		for _, f := range jsonFields {
			if k == f {
				// value is a field
				fields[k] = v
			}
		}

		for _, f := range jsonObjects {
			if k == f {
				// value is an object

				// skip empty objects
				// @TODO: move this logic to an Objects struct aliasing
				// map[string]interface{}
				if v == nil || zero.IsZero(v) {
					continue
				}

				// value is an object and not zero
				objects[k] = v
			}
		}
	}

	return Element{
		{{- if .DBIDField}}
			DBID: {{.Variable}}.DBID(),
		{{- end}}
		Fields:  fields,
		Objects: objects,
	}, nil
}

{{- if .DBIDField}}
func ({{.Variable}} {{.Name}}) DBIDField() string {
	return "{{.DBIDField}}"
}

func ({{.Variable}} {{.Name}}) DBID() string {
	return {{.Variable}}.{{.DBIDField}}
}
{{- end}}

func ({{.Variable}} *{{.Name}}) UnmarshalJSON(b []byte) error {
	{{$variable := .Variable}}
	// @TODO: make this a separate struct/method so Go generates better messages
	in := struct {
		{{range .Fields}} {{.Name}} {{.Type}} `json:"{{.Tags}}"` // {{.Comment}}
		{{end}}
	}{
		{{range .Fields}} {{.Name}}: {{$variable}}.{{.Name}},
		{{end}}
	}

	err := json.Unmarshal(b, &in)
	if err != nil {
		return err
	}
	*{{.Variable}} = {{.Name}}(in)
	return nil
}

func ({{.Variable}} {{.Name}}) JSONFields() []string {
	return []string{
		{{range .Fields}}{{if .IsObject}}{{else}}"{{.JSONName}}",{{end}}
		{{end}}
	}
}

func ({{.Variable}} {{.Name}}) Validate() error {
	{{$struct := .}}
	{{range .Fields}}
		{{if and (.ValidationRules.Required) (eq .Type "string")}}
		if {{$struct.Variable}}.{{.Name}} == "" {
			return errors.New("{{.Name}} ({{.JSONName}}) is a required field")
		}
		{{end}}

		{{if and (.ValidationRules.NotZero) (eq .Type "int")}}
		if {{$struct.Variable}}.{{.Name}} == 0 {
			return errors.New("{{.Name}} ({{.JSONName}}) can not be zero")
		}
		{{end}}

		{{if and (.ValidationRules.NotZero) (eq .Type "float64")}}
		if {{$struct.Variable}}.{{.Name}} == 0.0 {
			return errors.New("{{.Name}} ({{.JSONName}}) can not be zero")
		}
		{{end}}

		{{if and (.ValidationRules.MaxLength) (eq .Type "string")}}
		if utf8.RuneCountInString({{$struct.Variable}}.{{.Name}}) > {{.ValidationRules.MaxLength}} {
			return errors.New("{{.Name}} ({{.JSONName}}) can't be longer then {{.ValidationRules.MaxLength}} characters")
		}
		{{end}}
	{{end}}

	return nil
}

func ({{.Variable}} {{.Name}}) JSONObjects() []string {
	return []string{
		{{range .Objects}}"{{.}}",
		{{end}}
	}
}
{{end}}

// vim: ft=gotexttmpl noet
